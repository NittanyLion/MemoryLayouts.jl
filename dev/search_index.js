var documenterSearchIndex = {"docs":
[{"location":"#AlignMemory","page":"Home","title":"AlignMemory","text":"Documentation for AlignMemory.\n\n","category":"section"},{"location":"#AlignMemory.alignmem!-Tuple{AbstractDict, Vararg{Any}}","page":"Home","title":"AlignMemory.alignmem!","text":"`alignmem!( D :: AbstractDict, X... )``\n\nalignmem! is for internal use only.  It replaces the arrays stored in dictionary D at keys X with new arrays that are contiguous in memory.  \n\nalignmem!\n\ncalculates the total size needed for all arrays in X;\nallocates a single block of memory using Libc.malloc to hold all the data;\nrecursively copies the data from the old arrays into this new contiguous block;\nreplaces D[x] with a new array wrapper (preserving type, keys, offsets, etc.) that points to the new memory\n\nalignmem! takes two arguments:\n\nD: The dictionary containing the arrays;\nX...: a list of keys in D identifying which arrays to align\n\nwarning: important implementation details\nUsers should be mindful of the following important implementation details:the first array (with offset 0) takes ownership of the malloc'd memory (own=true)\nother arrays point to locations in the same block but do not own their location\nthis arrangement is safe as long as the first array is kept alive\nif the first array is resized then bad things can happen if the remaining arrays are accessed\nif any of the remaining arrays are resized then that array is no longer contiguous with the remaining arrays, but it will otherwise perform as expected\n\n\n\n\n\n","category":"method"},{"location":"#AlignMemory.alignmem-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T","page":"Home","title":"AlignMemory.alignmem","text":"alignmem(s; exclude = [])\n\nalignmem aligns the memory of arrays within the object s, whose type should be one of struct, AbstractArray, or AbstractDict\n\nalignmem creates a new instance of s (or copy of s) where the arrays are stored contiguously in memory.\n\nExcluded items are preserved as-is (or deep-copied in some contexts) but not packed into the contiguous memory block.\n\nwarning: important implementation details\nUsers should be mindful of the following important implementation details:the first array (with offset 0) takes ownership of the malloc'd memory (own=true)\nother arrays point to locations in the same block but do not own their location\nthis arrangement is safe as long as the first array is kept alive\nif the first array is resized then bad things can happen if the remaining arrays are accessed\nif any of the remaining arrays are resized then that array is no longer contiguous with the remaining arrays, but it will otherwise perform as expected\n\n\n\n\n\n","category":"method"},{"location":"#AlignMemory.deepalignmem-Tuple{Any}","page":"Home","title":"AlignMemory.deepalignmem","text":"`deepalignmem( x; exclude = [] )`\n\ndeepalignmem recursively aligns memory of arrays within x and its fields\n\nUnlike alignmem, which only aligns the immediate fields/elements of x, deepalignmem traverses the structure recursively.  In other words, deepalignmem is to alignmem what deepcopy is to copy.\n\nExcluded items are preserved as-is (or deep-copied in some contexts) but not packed into the contiguous memory block.\n\nwarning: important implementation details\nUsers should be mindful of the following important implementation details:the first array (with offset 0) takes ownership of the malloc'd memory (own=true)\nother arrays point to locations in the same block but do not own their location\nthis arrangement is safe as long as the first array is kept alive\nif the first array is resized then bad things can happen if the remaining arrays are accessed\nif any of the remaining arrays are resized then that array is no longer contiguous with the remaining arrays, but it will otherwise perform as expected\n\n\n\n\n\n","category":"method"},{"location":"#AlignMemory.newarrayofsametype-Tuple{Any, Any}","page":"Home","title":"AlignMemory.newarrayofsametype","text":"`newarrayofsametype(old, newdata)`\n\nFunction for internal use only that creates a new array wrapper of the same type and structure as old, but wrapping newdata.  This function recursively peels off array wrappers (like KeyedArray, OffsetArray, NamedDimsArray) to reach the underlying data, replaces it with newdata, and then re-wraps it. \n\nSupported Wrappers\n\nKeyedArray: preserves axis keys\nOffsetArray: preserves offsets\nNamedDimsArray: preserves dimension names\n\n\n\n\n\n","category":"method"},{"location":"#AlignMemory.transferadvance!-Tuple{AbstractDict, Any, Any, Ptr, Ref{Int64}}","page":"Home","title":"AlignMemory.transferadvance!","text":"`transferadvance(  D, x, TT, â–¶, offset )`\n\nThe function transferadvance is for internal use only.  It assigns memory from the memory block and then advances the offset.\n\n\n\n\n\n","category":"method"}]
}
