var documenterSearchIndex = {"docs":
[{"location":"#AlignMemory","page":"Home","title":"AlignMemory","text":"Documentation for AlignMemory.\n\n","category":"section"},{"location":"#AlignMemory.alignmem!-Tuple{AbstractDict, Vararg{Any}}","page":"Home","title":"AlignMemory.alignmem!","text":"alignmem!(D::AbstractDict, X...)\n\nReplaces the arrays stored in dictionary D at keys X with new arrays that are contiguous in memory.\n\nThis function:\n\nCalculates the total size needed for all arrays in X.\nAllocates a single block of memory using Libc.malloc to hold all the data.\nRecursively copies the data from the old arrays into this new contiguous block.\nReplaces D[x] with a new array wrapper (preserving type, keys, offsets, etc.) that points to the new memory.\n\nArguments\n\nD: The dictionary containing the arrays.\nX...: A list of symbols (keys in D) identifying which arrays to align.\n\nNotes\n\nThe first array (with offset 0) takes ownership of the malloc'd memory (own=true).\nOther arrays point to the same block but do not own it.\nThis arrangement is safe as long as the first array is kept alive.\n\n\n\n\n\n","category":"method"},{"location":"#AlignMemory.alignmem-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T","page":"Home","title":"AlignMemory.alignmem","text":"alignmem(s; exclude = [])\n\nAlign the memory of arrays within structure s.\n\nThis function creates a new instance of s (or copy of s) where the arrays are stored contiguously in memory. It handles AbstractArray, AbstractDict, and struct types.\n\nArguments\n\ns: The object to align (Array, Dict, or Struct).\nexclude: A list of keys (for Dicts/Arrays) or field names (for Structs) to exclude from alignment.          Excluded items are preserved as-is (or deep-copied in some contexts) but not packed into the contiguous memory block.\n\n\n\n\n\n","category":"method"},{"location":"#AlignMemory.deepalignmem-Tuple{Any}","page":"Home","title":"AlignMemory.deepalignmem","text":"deepalignmem(x; exclude = [])\n\nRecursively align memory of arrays within x and its fields.\n\nUnlike alignmem, which only aligns the immediate fields/elements of x, deepalignmem traverses the structure recursively.\n\nArguments\n\nx: The object to recursively align.\nexclude: A list of field names to exclude from recursion and alignment.          Excluded fields are deepcopy'd instead of being processed.\n\n\n\n\n\n","category":"method"},{"location":"#AlignMemory.newarrayofsametype-Tuple{Any, Any}","page":"Home","title":"AlignMemory.newarrayofsametype","text":"newarrayofsametype(old, newdata)\n\nCreate a new array wrapper of the same type and structure as old, but wrapping newdata. This function recursively peels off array wrappers (like KeyedArray, OffsetArray, NamedDimsArray) to reach the underlying data, replaces it with newdata, and then re-wraps it.\n\nSupported Wrappers\n\nKeyedArray: preserves axis keys.\nOffsetArray: preserves offsets.\nNamedDimsArray: preserves dimension names.\nAny: fallback that returns newdata directly (bottom of recursion).\n\n\n\n\n\n","category":"method"}]
}
