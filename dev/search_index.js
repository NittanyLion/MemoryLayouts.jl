var documenterSearchIndex = {"docs":
[{"location":"#AlignMemory","page":"Home","title":"AlignMemory","text":"Documentation for AlignMemory.\n\n","category":"section"},{"location":"#AlignMemory.AlignMem!-Tuple{AbstractDict, Vararg{Any}}","page":"Home","title":"AlignMemory.AlignMem!","text":"AlignMem!(D::AbstractDict, X...)\n\nReplaces the arrays stored in dictionary D at keys X with new arrays that are contiguous in memory.\n\nThis function:\n\nCalculates the total size needed for all arrays in X.\nAllocates a single block of memory using Libc.malloc to hold all the data.\nRecursively copies the data from the old arrays into this new contiguous block.\nReplaces D[x] with a new array wrapper (preserving type, keys, offsets, etc.) that points to the new memory.\n\nArguments\n\nD: The dictionary containing the arrays.\nX...: A list of symbols (keys in D) identifying which arrays to align.\n\nNotes\n\nThe first array (with offset 0) takes ownership of the malloc'd memory (own=true).\nOther arrays point to the same block but do not own it.\nThis arrangement is safe as long as the first array is kept alive.\n\n\n\n\n\n","category":"method"},{"location":"#AlignMemory.NewArrayOfSameType-Tuple{Any, Any}","page":"Home","title":"AlignMemory.NewArrayOfSameType","text":"NewArrayOfSameType(old, new_data)\n\nCreate a new array wrapper of the same type and structure as old, but wrapping new_data. This function recursively peels off array wrappers (like KeyedArray, OffsetArray, NamedDimsArray) to reach the underlying data, replaces it with new_data, and then re-wraps it.\n\nSupported Wrappers\n\nKeyedArray: preserves axis keys.\nOffsetArray: preserves offsets.\nNamedDimsArray: preserves dimension names.\nAny: fallback that returns new_data directly (bottom of recursion).\n\n\n\n\n\n","category":"method"}]
}
