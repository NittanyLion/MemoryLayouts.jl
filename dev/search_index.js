var documenterSearchIndex = {"docs":
[{"location":"#MemoryLayouts.jl","page":"Home","title":"MemoryLayouts.jl üß†‚ö°","text":"Optimize your memory layout for maximum cache efficiency.\n\nDocumentation for MemoryLayouts.","category":"section"},{"location":"#The-Problem-vs.-The-Solution","page":"Home","title":"üöÄ The Problem vs. The Solution","text":"Standard collections in Julia (Dicts, Arrays of Arrays, structs) often scatter data across memory, causing frequent cache misses. MemoryLayouts.jl packs this data into contiguous blocks.","category":"section"},{"location":"#How-it-works","page":"Home","title":"üîÆ How it works","text":"Function Description Analogy\nlayout( x ) Aligns immediate fields of x Like copy( x ) but packed\ndeeplayout( x ) Recursively aligns nested structures Like deepcopy( x ) but packed\nlayoutstats( x ) Dry run statistics for layout( x ) \ndeeplayoutstats( x ) Dry run statistics for deeplayout( x ) ","category":"section"},{"location":"#Usage","page":"Home","title":"üõ†Ô∏è Usage","text":"The package provides four exported functions: layout, deeplayout, layoutstats and deeplayoutstats. The distinction between the first two functions is that layout only applies to top level objects, whereas deeplayout applies to objects at all levels. The two examples below demonstrate their use.  As for the stats functions, these just do a dry run and print out some statistics on the degree of contiguity improvement a user can expect to see.","category":"section"},{"location":"#Example-for-layout","page":"Home","title":"üí° Example for layout","text":"The example below demonstrates how to use layout.\n\nusing MemoryLayouts, BenchmarkTools, StyledStrings\n\nfunction original( A = 10_000, L = 100, S = 5000)\n    x = Vector{Vector{Float64}}( undef, A )\n    s = Vector{Vector{Float64}}( undef, A )\n    for i ‚àà 1:A\n        x[i] = rand( L )\n        s[i] = rand( S )\n    end\n    return x\nend\n\nfunction computeme( X )\n    Œ£ = 0.0\n    for x ‚àà X \n        Œ£ += x[5] \n    end\n    return Œ£\nend\n\nprint( styled\"{(fg=0xff9999):original}: \" ); @btime computeme( X ) setup=(X = original(););\nprint( styled\"{(fg=0x99ff99):layout}: \" ); @btime computeme( X ) setup=(X = layout( original()););\n;","category":"section"},{"location":"#Example-for-deeplayout","page":"Home","title":"üí° Example for deeplayout","text":"The example below illustrates the use of deeplayout.\n\nusing MemoryLayouts, BenchmarkTools, StyledStrings\n\n\nstruct ùíÆ{X,Y,Z}\n    x :: X\n    y :: Y \n    z :: Z\nend\n\n\nfunction original( A = 10_000, L = 100, S = 5000)\n    x = Vector{Vector{Float64}}( undef, A )\n    s = Vector{Vector{Float64}}( undef, A )\n    for i ‚àà 1:A\n        x[i] = rand( L )\n        s[i] = rand( S )\n    end\n    return ùíÆ( [x[i] for i ‚àà 1:div( A, 3 )], [ x[i] for i ‚àà div( A, 3 )+1:div( 2*A, 3 )], [x[i] for i ‚àà div( 2*A, 3 )+1:A ] )\nend\n\nfunction computeme( X )\n    Œ£ = 0.0\n    for x ‚àà X.x  \n        Œ£ += x[5] \n    end\n    for y ‚àà X.y \n        Œ£ += y[37]\n    end\n    for z ‚àà X.z \n        Œ£ += z[5] \n    end\n    return Œ£\nend\n\nprintln( layoutstats( original() ) )\nprintln( deeplayoutstats( original() ) )\n\n\nprint( styled\"{(fg=0xff9999):original}: \" ); @btime computeme( X ) setup=(X = original(););\nprint( styled\"{(fg=0x99ff99):layout}: \" ); @btime computeme( X ) setup=(X = layout( original()););\nprint( styled\"{(fg=0x9999ff):deeplayout}: \" ); @btime computeme( X ) setup=(X = deeplayout( original()););\n;","category":"section"},{"location":"#Dry-Run-/-Statistics","page":"Home","title":"üìä Dry Run / Statistics","text":"You can inspect the potential improvements in memory contiguity without performing the actual allocation using layoutstats and deeplayoutstats.\n\njulia> using MemoryLayouts\n\njulia> data = [rand(10) for _ in 1:5];\n\njulia> layoutstats(data)\nLayoutStats(packed=400 b, blocks=5, span=2 kb, reduction=2 kb (82.6%))\n  Level 1: bytes=400 b, blocks=5, span=2 kb, reduction=2 kb (82.6%)\n\nThe output indicates:\n\npacked: The total size (in bytes) of the data if packed.\nblocks: The number of individual arrays identified.\nspan: The current distance between the minimum and maximum memory addresses of the data.\nreduction: The potential reduction in memory span.","category":"section"},{"location":"#Compatibility","page":"Home","title":"ü§ù Compatibility","text":"MemoryLayouts.jl is compatible with \nAxisKeys\nInlineStrings\nNamedDims.jl \nOffsetArrays\nthis assumes that those packages are loaded by the user (weak dependences)","category":"section"},{"location":"#SIMD-Alignment","page":"Home","title":"‚ö° SIMD Alignment","text":"Both layout and deeplayout accept an optional alignment keyword argument (default 1). This allows you to specify the byte alignment for the start of each array in the contiguous memory block.\n\nProper memory alignment is relevant for maximizing performance with SIMD (Single Instruction, Multiple Data) instructions (e.g., AVX2, AVX-512). On the other hand, such alignment leaves gaps between blocks of memory that are not a multiple of 64 bytes in length.\n\nAVX2 typically requires 32-byte alignment.\nAVX-512 typically requires 64-byte alignment.","category":"section"},{"location":"#Example","page":"Home","title":"üí° Example","text":"using MemoryLayouts\nstruct MyData\n    a::Vector{Float64}\n    b::Vector{Float64}\nend\n\ndata = MyData( rand( 100 ), rand( 100 ) )\n\naligneddata = layout( data; alignment = 64 )\n\npointer( aligneddata.a ) # Will be a multiple of 64\npointer( aligneddata.b ) # Will be a multiple of 64","category":"section"},{"location":"#Things-to-be-mindful-of","page":"Home","title":"‚ö†Ô∏è Things to be mindful of","text":"warning: Important details\nit operates on various types of collections including structs, arrays, and dicts\noperating on means that these collections are traversed, possibly recursively\nthe only objects that are copied into contiguous memory are isbits arrays (think arrays of numbers, InlineStrings (but not regular strings), etcetera )\nthe more scattered is the memory before the layout change, the greater is the potential speed gain\nlayout copies, but only the top level; see example 2 above\ndeeplayout copies all levels\nno attempt is made to make empty arrays contiguous\nno attempt is made to make objects that are not one of the covered collections contiguous\nthe package assigns one memory block and within that block uses unsafe_wraps to obtain Julia arrays\nthis can have 'interesting' consequences if misused\nergo, this package should not be used by those new to programming \nobjects can be excluded from layout changes via the exclude keyword\nthere is overhead in laying out memory initially and (to a much lesser extent) to running the finalizer\nthus, MemoryLayouts works best for aligning memory in a collection once and then using it for an extended stretch\nresizing one of the arrays whose memory was laid out by MemoryLayouts is safe, but likely results in that array being moved to another location in memory assigned by Julia (not by MemoryLayouts)\nreassigning an array assigned by MemoryLayouts to another location, e.g. by writing y[i] = ... does not release the entire memory block\nthe entire memory block is only released if the entire collection loses scope\nby default, MemoryLayouts packs in the isbits arrays as tightly as it can\nthis may not be optimal, e.g. for AVX-512 computations\nuse the alignment=64 option to give up some contiguity and regain alignment desired for optimal AVX-512 performance","category":"section"},{"location":"#Function-documentation","page":"Home","title":"üìñ Function documentation","text":"","category":"section"},{"location":"#MemoryLayouts.layout","page":"Home","title":"MemoryLayouts.layout","text":"layout(s; exclude = Symbol[], alignment::Int=1)\n\nlayout aligns the memory of arrays within the object s, whose type should be one of struct, AbstractArray, or AbstractDict\n\nlayout creates a new instance of s (or copy of s) where the arrays are stored contiguously in memory.\n\nThe alignment keyword argument specifies the memory alignment in bytes. This is particularly useful for SIMD operations, where aligning data to 16, 32, or 64 bytes can improve performance.\n\nExcluded items are preserved as-is (or deep-copied in some contexts) but not packed into the contiguous memory block.\n\nwarning: important implementation details\nUsers should be mindful of the following important implementation details:aligned arrays share a single contiguous memory block\nresizing any of the arrays (push!, append!) will break this contiguity for that array (it will be reallocated elsewhere)\nContiguity is maintained until an array is resized or reassigned\n\n\n\n\n\n","category":"function"},{"location":"#MemoryLayouts.deeplayout","page":"Home","title":"MemoryLayouts.deeplayout","text":"deeplayout( x; exclude = Symbol[], alignment::Int=1 )\n\ndeeplayout recursively aligns memory of arrays within x and its fields\n\nUnlike layout, which only aligns the immediate fields/elements of x, deeplayout traverses the structure recursively.  In other words, deeplayout is to layout what deepcopy is to copy.\n\nThe alignment keyword argument specifies the memory alignment in bytes. This is particularly useful for SIMD operations, where aligning data to 16, 32, or 64 bytes can improve performance.\n\nExcluded items are preserved as-is (or deep-copied in some contexts) but not packed into the contiguous memory block.\n\nwarning: important implementation details\nUsers should be mindful of the following important implementation details:aligned arrays share a single contiguous memory block\nresizing any of the arrays (push!, append!) will break this contiguity for that array (it will be reallocated elsewhere)\nContiguity is maintained until an array is resized or reassigned\n\n\n\n\n\n","category":"function"},{"location":"#MemoryLayouts.layoutstats","page":"Home","title":"MemoryLayouts.layoutstats","text":"layoutstats( s; exclude = Symbol[], alignment :: Int = 1 )\n\nReturns a LayoutStats object containing statistics about the memory layout if layout( s ) were called.\n\nThe returned object includes:\n\nbytes: Total size (in bytes) of the data that would be packed.\nblocks: Number of individual arrays identified.\nspan: The distance between the minimum and maximum memory addresses of the data.\nreduction: The potential reduction in memory span (span - bytes).\n\n\n\n\n\n","category":"function"},{"location":"#MemoryLayouts.deeplayoutstats","page":"Home","title":"MemoryLayouts.deeplayoutstats","text":"deeplayoutstats( x; exclude = Symbol[], alignment :: Int = 1 )\n\nReturns a LayoutStats object containing statistics about the memory layout if deeplayout( x ) were called.\n\nThe returned object includes:\n\nbytes: Total size (in bytes) of the data that would be packed.\nblocks: Number of individual arrays identified.\nspan: The distance between the minimum and maximum memory addresses of the data.\nreduction: The potential reduction in memory span (span - bytes).\n\n\n\n\n\n","category":"function"}]
}
