var documenterSearchIndex = {"docs":
[{"location":"#MemoryLayouts.jl","page":"Home","title":"MemoryLayouts.jl üß†‚ö°","text":"Optimize your memory layout for maximum cache efficiency.\n\nDocumentation for MemoryLayouts.","category":"section"},{"location":"#The-Problem-vs.-The-Solution","page":"Home","title":"üöÄ The Problem vs. The Solution","text":"Standard collections in Julia (Dicts, Arrays of Arrays, structs) often scatter data across memory, causing frequent cache misses. MemoryLayouts.jl packs this data into contiguous blocks.","category":"section"},{"location":"#How-it-works","page":"Home","title":"üîÆ How it works","text":"Function Description Analogy\nalignmem( x ) Aligns immediate fields of x Like copy( x ) but packed\ndeepalignmem( x ) Recursively aligns nested structures Like deepcopy( x ) but packed","category":"section"},{"location":"#Usage","page":"Home","title":"Usage","text":"The package provides two exported functions: alignmem and deepalignmem. The distinction is that alignmem only applies to top level objects, whereas deepalignmem applies to objects at all levels. The two examples below demonstrate their use.","category":"section"},{"location":"#SIMD-Alignment","page":"Home","title":"SIMD Alignment","text":"Both alignmem and deepalignmem accept an optional alignment keyword argument (default 1). This allows you to specify the byte alignment for the start of each array in the contiguous memory block.\n\nProper memory alignment is crucial for maximizing performance with SIMD (Single Instruction, Multiple Data) instructions (e.g., AVX2, AVX-512).\n\nAVX2 typically requires 32-byte alignment.\nAVX-512 typically requires 64-byte alignment.","category":"section"},{"location":"#Example","page":"Home","title":"Example","text":"using MemoryLayouts\nstruct MyData\n    a::Vector{Float64}\n    b::Vector{Float64}\nend\n\ndata = MyData( rand( 100 ), rand( 100 ) )\n\n# Align for AVX-512 (64-byte alignment)\naligneddata = alignmem( data; alignment = 64 )\n\n# Verify alignment\npointer( aligneddata.a ) # Will be a multiple of 64\npointer( aligneddata.b ) # Will be a multiple of 64","category":"section"},{"location":"#Example-for-alignmem","page":"Home","title":"Example for alignmem","text":"The example below demonstrates how to use alignmem.\n\nusing MemoryLayouts, BenchmarkTools, StyledStrings\n\nfunction original( A = 10_000, L = 100, S = 5000)\n    x = Vector{Vector{Float64}}( undef, A )\n    s = Vector{Vector{Float64}}( undef, A )\n    for i ‚àà 1:A\n        x[i] = rand( L )\n        s[i] = rand( S )\n    end\n    return x\nend\n\nfunction computeme( X )\n    Œ£ = 0.0\n    for x ‚àà X \n        Œ£ += x[5] \n    end\n    return Œ£\nend\n\nprint( styled\"{(fg=0xff9999):original}: \" ); @btime computeme( X ) setup=(X = original();)\nprint( styled\"{(fg=0x99ff99):alignmem}: \" ); @btime computeme( X ) setup=(X = alignmem( original());)\n;","category":"section"},{"location":"#Example-for-deepalignmem","page":"Home","title":"Example for deepalignmem","text":"The example below illustrates the use of deepalignmem.\n\nusing MemoryLayouts, BenchmarkTools, StyledStrings\n\n\nstruct ùíÆ{X,Y,Z}\n    x :: X\n    y :: Y \n    z :: Z\nend\n\n\nfunction original( A = 10_000, L = 100, S = 5000)\n    x = Vector{Vector{Float64}}( undef, A )\n    s = Vector{Vector{Float64}}( undef, A )\n    for i ‚àà 1:A\n        x[i] = rand( L )\n        s[i] = rand( S )\n    end\n    return ùíÆ( [x[i] for i ‚àà 1:div( A, 3 )], [ x[i] for i ‚àà div( A, 3 )+1:div( 2*A, 3 )], [x[i] for i ‚àà div( 2*A, 3 )+1:A ] )\nend\n\nfunction computeme( X )\n    Œ£ = 0.0\n    for x ‚àà X.x  \n        Œ£ += x[5] \n    end\n    for y ‚àà X.y \n        Œ£ += y[37]\n    end\n    for z ‚àà X.z \n        Œ£ += z[5] \n    end\n    return Œ£\nend\n\nprint( styled\"{(fg=0xff9999):original}: \" ); @btime computeme( X ) setup=(X = original();)\nprint( styled\"{(fg=0x99ff99):alignmem}: \" ); @btime computeme( X ) setup=(X = alignmem( original());)\nprint( styled\"{(fg=0x9999ff):deepalignmem}: \" ); @btime computeme( X ) setup=(X = deepalignmem( original());)\n;","category":"section"},{"location":"#Compatibility-and-Extensions","page":"Home","title":"üîå Compatibility & Extensions","text":"MemoryLayouts.jl is further compatible with \nAxisKeys\nInlineStrings\nNamedDimsArrays \nOffsetArrays\nthis assumes that those packages are loaded by the user","category":"section"},{"location":"#Function-documentation","page":"Home","title":"Function documentation","text":"","category":"section"},{"location":"#Critical-Usage-Note","page":"Home","title":"‚ö†Ô∏è Critical Usage Note","text":"warning: Memory Contiguity\nAligned arrays share a single contiguous memory block.\nResizing aligned arrays (push!, append!) will cause them to be reallocated elsewhere, breaking memory contiguity.\nAny arrays that you may wish to reassign or resize at a later point in time should be specified in the optional exclude argument.Implementation Note: The code allocates a single chunk of memory (Vector{UInt8}) to hold all the data. This memory is kept alive by the aligned arrays.","category":"section"},{"location":"#MemoryLayouts.alignmem","page":"Home","title":"MemoryLayouts.alignmem","text":"alignmem(s; exclude = Symbol[], alignment::Int=1)\n\nalignmem aligns the memory of arrays within the object s, whose type should be one of struct, AbstractArray, or AbstractDict\n\nalignmem creates a new instance of s (or copy of s) where the arrays are stored contiguously in memory.\n\nThe alignment keyword argument specifies the memory alignment in bytes. This is particularly useful for SIMD operations, where aligning data to 16, 32, or 64 bytes can improve performance.\n\nExcluded items are preserved as-is (or deep-copied in some contexts) but not packed into the contiguous memory block.\n\nwarning: important implementation details\nUsers should be mindful of the following important implementation details:aligned arrays share a single contiguous memory block\nresizing any of the arrays (push!, append!) will break this contiguity for that array (it will be reallocated elsewhere)\nstrict contiguity is only guaranteed immediately after alignment\n\n\n\n\n\n","category":"function"},{"location":"#MemoryLayouts.deepalignmem","page":"Home","title":"MemoryLayouts.deepalignmem","text":"deepalignmem( x; exclude = Symbol[], alignment::Int=1 )\n\ndeepalignmem recursively aligns memory of arrays within x and its fields\n\nUnlike alignmem, which only aligns the immediate fields/elements of x, deepalignmem traverses the structure recursively.  In other words, deepalignmem is to alignmem what deepcopy is to copy.\n\nThe alignment keyword argument specifies the memory alignment in bytes. This is particularly useful for SIMD operations, where aligning data to 16, 32, or 64 bytes can improve performance.\n\nExcluded items are preserved as-is (or deep-copied in some contexts) but not packed into the contiguous memory block.\n\nwarning: important implementation details\nUsers should be mindful of the following important implementation details:aligned arrays share a single contiguous memory block\nresizing any of the arrays (push!, append!) will break this contiguity for that array (it will be reallocated elsewhere)\nstrict contiguity is only guaranteed immediately after alignment\n\n\n\n\n\n","category":"function"}]
}
