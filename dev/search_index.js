var documenterSearchIndex = {"docs":
[{"location":"#AlignMemory.jl","page":"Home","title":"AlignMemory.jl","text":"Documentation for AlignMemory.","category":"section"},{"location":"#Purpose","page":"Home","title":"Purpose","text":"The purpose of the AlignMemory.jl package is to make arrays contained in collections like structs, arrays, and dicts occupy contiguous memory space automatically.  The reason that this can be advantageous is that using contiguous memory for related objects can improve performance. ","category":"section"},{"location":"#Usage","page":"Home","title":"Usage","text":"The package provides two exported functions: alignmem and deepalignmem.  The distinction is that alignmem only applies to top level objects, whereas deepalignmem applies to objects at all levels. The two examples below demonstrate their use.","category":"section"},{"location":"#Example-for-alignmem","page":"Home","title":"Example for alignmem","text":"The example below demonstrates how to use alignmem.\n\nusing AlignMemory, BenchmarkTools, StyledStrings\n\nfunction original( A = 10_000, L = 100, S = 5000)\n    x = Vector{Vector{Float64}}(undef, A)\n    s = Vector{Vector{Float64}}(undef, A)\n    for i ‚àà 1:A\n        x[i] = rand( L )\n        s[i] = rand( S )\n    end\n    return x\nend\n\nfunction computeme( X )\n    Œ£ = 0.0\n    for x ‚àà X \n        Œ£ += x[5] \n    end\n    return Œ£\nend\n\nprint( styled\"{(fg=0xff9999):original}: \" ); @btime computeme( X ) setup=(X = original();)\nprint( styled\"{(fg=0x99ff99):alignmem}: \" ); @btime computeme( X ) setup=(X = alignmem( original());)\n;","category":"section"},{"location":"#Example-for-deepalignmem","page":"Home","title":"Example for deepalignmem","text":"The example below illustrates the use of deepalignmem.\n\nusing AlignMemory, BenchmarkTools, StyledStrings\n\n\nstruct ùíÆ{X,Y,Z}\n    x :: X\n    y :: Y \n    z :: Z\nend\n\n\nfunction original( A = 10_000, L = 100, S = 5000)\n    x = Vector{Vector{Float64}}(undef, A)\n    s = Vector{Vector{Float64}}(undef, A)\n    for i ‚àà 1:A\n        x[i] = rand( L )\n        s[i] = rand( S )\n    end\n    return ùíÆ( [x[i] for i ‚àà 1:div(A,3)], [ x[i] for i ‚àà div(A,3)+1:div(2*A,3)], [x[i] for i ‚àà div(2*A,3)+1:A ] )\nend\n\nfunction computeme( X )\n    Œ£ = 0.0\n    for x ‚àà X.x  \n        Œ£ += x[5] \n    end\n    for y ‚àà X.y \n        Œ£ += y[37]\n    end\n    for z ‚àà X.z \n        Œ£ += z[5] \n    end\n    return Œ£\nend\n\nprint( styled\"{(fg=0xff9999):original}: \" ); @btime computeme( X ) setup=(X = original();)\nprint( styled\"{(fg=0x99ff99):alignmem}: \" ); @btime computeme( X ) setup=(X = alignmem( original());)\nprint( styled\"{(fg=0x9999ff):deepalignmem}: \" ); @btime computeme( X ) setup=(X = deepalignmem( original());)\n;","category":"section"},{"location":"#Other-array-types","page":"Home","title":"Other array types","text":"AlignMemory.jl is further compatible with \nAxisKeys\nInlineStrings\nNamedDimsArrays \nOffsetArrays\nthis assumes that those packages are loaded by the user","category":"section"},{"location":"#Function-documentation","page":"Home","title":"Function documentation","text":"","category":"section"},{"location":"#Caveats","page":"Home","title":"Caveats","text":"warning: implementation details to be mindful of\navoid resizing or reassigning arrays that are realigned\nany arrays that you may wish to reassign or resize at a later point in time should be specified in the optional exclude argument\nwhat the code does:\nthe code allocates a single chunk of memory via malloc * this memory will be owned by the first array of the ones that are to be aligned\nso when that that array is garbage-collected, the remaining aligned arrays will no longer be accessible\nthis is version 0.1 of this package, so there may still be some issues","category":"section"},{"location":"#AlignMemory.alignmem","page":"Home","title":"AlignMemory.alignmem","text":"alignmem(s; exclude = [])\n\nalignmem aligns the memory of arrays within the object s, whose type should be one of struct, AbstractArray, or AbstractDict\n\nalignmem creates a new instance of s (or copy of s) where the arrays are stored contiguously in memory.\n\nExcluded items are preserved as-is (or deep-copied in some contexts) but not packed into the contiguous memory block.\n\nwarning: important implementation details\nUsers should be mindful of the following important implementation details:the first array (with offset 0) takes ownership of the malloc'd memory (own=true)\nother arrays point to locations in the same block but do not own their location\nthis arrangement is safe as long as the first array is kept alive\nif the first array is resized then bad things can happen if the remaining arrays are accessed\nif any of the remaining arrays are resized then that array is no longer contiguous with the remaining arrays, but it will otherwise perform as expected\n\n\n\n\n\n","category":"function"},{"location":"#AlignMemory.deepalignmem","page":"Home","title":"AlignMemory.deepalignmem","text":"deepalignmem( x; exclude = [] )\n\ndeepalignmem recursively aligns memory of arrays within x and its fields\n\nUnlike alignmem, which only aligns the immediate fields/elements of x, deepalignmem traverses the structure recursively.  In other words, deepalignmem is to alignmem what deepcopy is to copy.\n\nExcluded items are preserved as-is (or deep-copied in some contexts) but not packed into the contiguous memory block.\n\nwarning: important implementation details\nUsers should be mindful of the following important implementation details:the first array (with offset 0) takes ownership of the malloc'd memory (own=true)\nother arrays point to locations in the same block but do not own their location\nthis arrangement is safe as long as the first array is kept alive\nif the first array is resized then bad things can happen if the remaining arrays are accessed\nif any of the remaining arrays are resized then that array is no longer contiguous with the remaining arrays, but it will otherwise perform as expected\n\n\n\n\n\n","category":"function"}]
}
